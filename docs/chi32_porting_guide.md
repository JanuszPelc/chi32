# CHI32: Porting Guide

## Introduction

This guide provides essential information for developers who want to port the Cascading Hash Interleave 32-bit (CHI32) algorithm to new programming languages or platforms.

It covers the core algorithm components, necessary constants, and detailed procedures for verifying the correctness of an implementation against canonical data to ensure conformance with the CHI32 standard.

## Terminology

### Input naming conventions

CHI32 documentation and tools use two naming conventions for its 64-bit inputs, depending on context:

- **Core primitive (`selector`, `index`)**:
  Used when describing the algorithm's internal logic. CHI32 acts as a pure function: `value = f(selector, index)`, enabling stateless, random-access generation. These names are conceptually similar to `key` and `counter` in counter-based generators (CBRNGs).

- **Sequential usage (`seed`, `phase`)**:
  Suggested for idiomatic wrappers emulating stateful PRNGs and used in tools, test harnesses, and canonical datasets. In this context, one input (the seed) stays fixed while the other (the phase) increments.

Both pairs describe the same inputs: the core terms emphasize functional purity, while the sequential terms align with PRNG-like usage.

### Core primitive

A fundamental, self-contained, pure function that forms a basic building block of the CHI32 algorithm. The core primitives are `DeriveValueAt`, `ApplyCascadingHashInterleave`, and `UpdateHashValue`.

### Canonical data

A standardized set of reference output values generated by CHI32 for specific, well-defined inputs and verification patterns. Canonical data serves as the ground truth for validating any implementation, as detailed later.

### Sequential strategy

A suggested method for generating a sequence of pseudo-random numbers with `DeriveValueAt`. The `selector` stays fixed while the `index` is incremented for each subsequent value, emulating a traditional stateful PRNG.

## Core primitive overview

CHI32 is composed of three core primitives.

### `DeriveValueAt(selector, index)`

The primary public-facing primitive. It takes a 64-bit `selector` and a 64-bit `index`, calls `ApplyCascadingHashInterleave` to compute a 64-bit intermediate state, then extracts a 32-bit result using a state-dependent offset.

### `ApplyCascadingHashInterleave(selector, index)`

Performs the main mixing work. It combines and transforms the inputs through several hashing and bitwise stages and produces a 64-bit intermediate state. It can also be used to scramble any 64-bit input pair into a well-mixed 64-bit form.

### `UpdateHashValue(previousHash, value)`

A utility primitive used internally by `ApplyCascadingHashInterleave`. It updates a running 32-bit hash with a new input value and is useful in other non-cryptographic scenarios.

## Normative reference implementations

The official CHI32 repository maintains normative reference implementations across multiple languages. Each one:

- Produces bit-for-bit identical output for identical `(selector, index)` inputs
- Is rigorously validated against canonical datasets
- Faithfully executes the algorithm, preserving all statistical properties

Although the C# version is the initial reference, every normative implementation in the repository is equally authoritative.

## Key porting considerations

When porting CHI32, pay close attention to the following technical details for achieving a correct and conformant implementation:

### Integer sizes and overflow behavior

CHI32 uses 64-bit integers for `selector`, `index`, and the intermediate state, and 32-bit integers for final results and `UpdateHashValue` internals. Arithmetic assumes wrap-around semantics on overflow, matching C# `unchecked` or standard C behavior.

### Bitwise operations

All fixed-width bitwise operators are used: AND, OR, XOR, NOT, left/right shifts (`<<`, `>>`), and left rotations.

### Endianness (for canonical data verification)

The algorithm itself is endian-neutral; canonical data files are stored in little-endian byte order. Implementations on big-endian systems must byte-swap when reading these files.

### Signed vs. unsigned representation

Inputs are signed 64-bit integers, but internal logic treats their bit patterns as unsigned. Preserve the exact bit patterns, ensure wrap-around behavior, and avoid sign-extension during shifts and conversions.

## Conformance testing

### Role and structure of reference datasets

Canonical data serves as the authoritative reference for validating the correctness of CHI32 implementations covering three primary strategies:

Files reside in `/validation/canonical_data/` folder. Data are little-endian `.bin` files; metadata lives in `chi32_canonical_meta.csv`.

CSV columns are:

1. `logical_name`
2. `strategy_code` (`0` = Sequential, `1` = Swapped, `2` = Feedback)
3. `seed` (64-bit)
4. `phase` (64-bit)
5. `length` (32-bit)
6. `bin_filename`

Comment lines start with `#` and should be ignored.

### Verification strategies using canonical data

The canonical test data in `chi32_canonical_meta.csv` uses the column headers `seed` and `phase`. These map to the `selector` and `index` parameters of `DeriveValueAt`, with the mapping varying by strategy:

- **Sequential strategy**:
  `seed` maps to the fixed `selector`.
  `phase` maps to the initial, incrementing `index`.

- **Swapped strategy**:
  `seed` maps to the fixed `index`.
  `phase` maps to the initial, decrementing `selector`.
  This inversion is intentional and tests argument independence.

- **Feedback strategy**:
  `seed` maps to the initial `selector`.
  `phase` maps to the initial `index`.
  Further values evolve through a feedback loop as defined in the pattern below.

### Conceptual verification tests

#### Sequential strategy pattern

```pseudo
function VerifySequentialStrategy(selector, phase, length, expected):
    idx = phase
    for i from 0 to length-1:
        v = DeriveValueAt(selector, idx)
        if v != expected[i]:
            return False
        idx += 1
    return True
````

#### Swapped argument strategy pattern

```pseudo
function VerifySwappedStrategy(phase, index, length, expected):
    sel = phase
    for i from 0 to length-1:
        v = DeriveValueAt(sel, index)
        if v != expected[i]:
            return False
        sel -= 1
    return True
```

#### Feedback strategy pattern

```pseudo
function VerifyFeedbackStrategy(seed, phase, length, expected):
    sel = seed
    idx = phase
    for i from 0 to length-1:
        v = DeriveValueAt(sel, idx)
        if v != expected[i]:
            return False
        nextSel = ((sel & 0xFFFFFFFF) << 32) | (idx >> 32)
        nextIdx = ((idx & 0xFFFFFFFF) << 32) | v
        sel = nextSel
        idx = nextIdx
    return True
```

### Conformance criteria

An implementation is conformant when all three strategies match canonical output bit-for-bit and handle all edge cases.

## Summary and porting steps

1. **Select a reference implementation**:
   Study `DeriveValueAt`, `ApplyCascadingHashInterleave`, and `UpdateHashValue`.

2. **Port to the target language**:
   Recreate the three primitives, observing Sections 5.1â€“5.4.

3. **Implement and execute conformance tests**:
   Run the sequential, swapped, and feedback tests and compare against canonical data.

4. **Review conformance criteria**:
   Ensure all edge cases pass.

5. **Confirm compliance**:
   When all tests succeed, the port is compliant with CHI32.

## Contributing your language port to the CHI32 repository

### License compatibility

All contributions must use the MIT license.

### Source file requirements

Ports should include the standard MIT header and your own copyright.

```c
// MIT License
//
// Copyright (c) YEAR Your Name
//
// Permission is hereby granted, free of charge, to any person [...]
```

Ports may optionally include an attribution to the CHI32 project using the following format:

```c
// Implementation of Cascading Hash Interleave 32-bit (CHI32)
// Documentation and specification: https://github.com/JanuszPelc/chi32
```

### Project structure

Recommended layout under `/<language>/`:

```
src/         core primitives
tests/       conformance tests
tools/       (optional) utilities
benchmarks/  (optional) performance code
examples/    (optional) usage demos
docs/        (optional) extra docs
```

### Test suite and verification

Provide clear build and test commands (for example, `make test`, `dotnet test`, or `zig build test`).

The test suite must be straightforward to execute for any reviewer or user. It should clearly demonstrate that your port passes all conformance tests as specified in the conformance testing section.

### Acceptance and code ownership

Accepted ports list the contributor in `CONTRIBUTORS.md` as code owner, who maintains the implementation thereafter.

If you become unresponsive, the repository owner may temporarily assume maintenance duties or reassign the implementation if necessary.
